// フィボナッチ数列のサンプルプログラム
#include <stdio.h>
/*
注意：インデックスは0スタートです．つまり，f(0)=1, f(1)=1, f(2)=2, f(3)=3,...です．
1スタートにしたい場合（f(1)=1, f(2)=1, f(3)=2, f(4)=3,...）は，
関数の定義にでてくる数字を1つずつずらしておく必要があります．
*/

// 再帰関数を使った関数の１つ目
int fib_rec1(int n){
  if (n==0 || n ==1){ // || は「または」．条件を書くときには「かつ」と「または」の違いに注意
    return 1;
  }
  else{
    return fib_rec1(n-2)+fib_rec1(n-1);
  }
}

// 再帰関数を使った関数の2つ目
int fib_rec2(int n){
  if (n<=1){ // 不等号で書けば，もし負の整数を入力してもとりあえず「1」が答えになる．「i<2」でも同じ．
    return 1;
  }
  else{
    return fib_rec2(n-2)+fib_rec2(n-1);
  }
}

// 再帰関数を使った関数の3つ目
int fib_rec3(int n){
  if (n==0){
    return 1;
  }
  else if (n==1){ // この場合はifだけでも同じです．
    return 1;
  }
  else{
    return fib_rec3(n-2)+fib_rec3(n-1);
  }
}

// for文を使った関数
int fib_for(int n){
  int i,x,y,z;
  x = 1;
  y = 1;
  z = 1;
  for (i = 1; i <= n-1; i++){ // この書き方に注意
    z = x+y;
    x = y;
    y = z;
  }
  return z;
}
/*
for文を使う関数は，だいたいみなさん同じようなプログラムになっていました．
n=0やn=1のときの扱いに困り，if文で分岐しているものもありましたが，例えば
上のような書き方もあります．たとえばn=0のとき，forの中ではiが1から0まで
動くように見えますが，実はこのようなとき，for文は無視されます．
*/

int main(){
  int n;
  printf("Insert integer \n");
  scanf("%d",&n);
  printf("method 1 (recursion 1): %d\n", fib_rec1(n));
  printf("method 2 (recursion 2): %d\n", fib_rec2(n));
  printf("method 3 (recursion 3): %d\n", fib_rec3(n));
  printf("method 4 (for): %d\n", fib_for(n));
}


/*
散見されたミス：
例えば再帰関数のとき，
int fib_rec1(int n){
  int fac(int n){
    if (n==0 || n ==1){ 
      return 1;
    }
    else{
     return fac(n-2)+fac(n-1);
   }
  }
}
こういう感じのプログラムになっている人が何人かいました．
先週の授業では fac という再帰関数の定義を例として紹介しましたが，階乗の計算はフィボナッチ数列とは何の関係もありませんよね．
同様にfor文の方でも
int fib_for(int n){
  int sum(int n){...
となっている人が何人かいました．フィボナッチ数列を定義する関数の中で1+...+nを計算する関数を定義する必要はないですよね．
*/

/*
その他の注意
1つ目：
ファイル名や関数名には適切な名前をつけるのをおすすめします．講義のサンプルプログラムを
ベースにプログラムを書くのは全く問題ないのですが，例えば関数名がfac（階乗）のままだと，
1ヶ月後，あるいは数年後に読み直したときに意味不明だと思います（私も同じような経験を
何度もやらかしました）．同様に，ちょっとしたことでもとにかくコメントを書くことを
おすすめします．
2つ目：
フィボナッチ数列は一般項が書けますから，それを使った関数の定義もありえます（そういう
指摘がありました）．もちろんその通りです．一般に，一般項が書ける漸化式の場合は，それを
書いてしまう方が演算回数の削減や丸め誤差の削減に繋がります．ただし，フィボナッチ数列
の場合は少し注意が必要で，（この場合は現実的に大した問題にはなりませんが）ルートの計算
には丸め誤差がある，double型を使うのでメモリ使用量が増える，といった欠点もあります．
3つ目：
「nを大きな値にしたときに，適切に計算されない」といった質問がありました．int型で扱える
整数には範囲があることを思い出してください．なお，こういう試み（遊び？）をしてみることは
とても重要だと思います．
4つ目：
興味があれば，再帰関数を使った場合に，たとえばf(10)をするのに足し算を何回必要としているか
数えてみてください．for文より多いことが分かると思います．足し算はこんなふうに数えます．
f(10) = f(9) + f(8) ... (1)
f(9) = f(8) + f(7) ... (2)
f(8) = f(7) + f(6) ... (3)
f(8) = f(7) + f(6) ... (4)
といった感じです．(3)は(1)のf(8)の計算．(4)は(2)のf(8)の計算です．人間が見れば同じ
計算ですが，計算機の中では別々に行われます．
*/
